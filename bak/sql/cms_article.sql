INSERT INTO `cms_article` (`id`, `status`, `description`, `createTime`, `createBy`, `updateTime`, `updateBy`, `deleteStatus`, `deleteTime`, `deleteBy`, `title`, `summary`, `author`, `source`, `keywords`, `type`, `thumbId`, `fileId`, `contentUrl`, `mediaId`, `weight`, `content`, `browseCount`, `linkCount`, `collectCount`, `shareCount`, `isComment`, `commentCount`, `publishTime`, `publishBy`, `version`) VALUES ('021f83c3-968d-4d45-8ab7-bc7104a71a75', 2, '', '2021-08-17 00:04:42.676274', NULL, '2021-09-24 16:19:49.000000', '62310947-7b54-45c8-a5da-19837f2541a4', 0, NULL, NULL, '【uni-app】使用写字板，实现手写签名----直接使用版', '【uni-app】使用写字板，实现手写签名----直接使用版', NULL, NULL, NULL, 0, '', NULL, '', '', 0, '<div>\n<div>\n<article class=\"article\" data-entry-id=\"6995835945148743694\" data-draft-id=\"6995819391065849893\" data-original-type=\"0\" data-v-4a869969=\"\" data-v-b7597dfc=\"\">\n<div class=\"article-content\" data-v-4a869969=\"\">\n<div class=\"markdown-body\">\n<h3 data-id=\"heading-0\">需求</h3>\n<p>用户需在<code>APP</code>或<code>小程序</code>使用手写的方式签字或签名</p>\n<h3 data-id=\"heading-1\">效果图片</h3>\n<p><img class=\"medium-zoom-image\" src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e7da0f83e2d407ea57cbb9e5f059609~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"微信截图_20210813155247.png\" /></p>\n<h3 data-id=\"heading-2\">实现方式</h3>\n<ol>\n<li>封装成组件调用<code>（推荐）</code>，如需了解使用可点击前往---【<a title=\"https://juejin.cn/post/6996835642743193630\" href=\"https://juejin.cn/post/6996835642743193630\" target=\"_blank\" rel=\"noopener\">封装组件版</a>】</li>\n<li>使用的页面内直接使用，目前的教程就是直接使用的，未封装成组件</li>\n</ol>\n<h3 data-id=\"heading-3\">使用</h3>\n<h4 data-id=\"heading-4\">第一步：使用的页面，如<code>index.vue</code></h4>\n<pre><code class=\"copyable\">&lt;!-- canvas --&gt;\n&lt;canvas class=\"mycanvas\" canvas-id=\"mycanvas\" @touchstart=\"touchstart\" @touchmove=\"touchmove\" @touchend=\"touchend\"&gt;&lt;/canvas&gt;\n\n&lt;!-- 底部操作按钮 --&gt;\n&lt;view class=\"footer\"&gt;\n        &lt;view class=\"left\" @click=\"finish\"&gt;保存&lt;/view&gt;\n        &lt;view class=\"right\" @click=\"clear\"&gt;清除&lt;/view&gt;\n        &lt;view class=\"close\" @click=\"close\"&gt;关闭&lt;/view&gt;\n&lt;/view&gt;\n\n\n&lt;view @click=\'createCanvas()\'&gt;点击触发写字板&lt;/view&gt;\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>上面的<code>canvas</code>共绑定了3个方法</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>方法解读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>@touchstart</td>\n<td>手写触摸开始，获取到起点</td>\n</tr>\n<tr>\n<td>@touchmove</td>\n<td>手写触摸移动，获取到路径点</td>\n</tr>\n<tr>\n<td>@touchend</td>\n<td>手写触摸结束</td>\n</tr>\n</tbody>\n</table>\n<h4 data-id=\"heading-5\">第二步：定义所需数据</h4>\n<pre><code class=\"copyable\">export default {\n	data() {\n		return {\n                    //绘图图像\n                    ctx: \'\', \n                    //路径点集合\n                    points: [], \n                    //签名图片\n                    SignatureImg: \'\'\n                }\n              }\n           }\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 data-id=\"heading-6\">第三步：绑定方法，书写逻辑</h4>\n<ol>\n<li>createCanvas（）----<code>该方法主要是创建了画布</code></li>\n<li>touchstart（）----<code>触摸开始，获取到起点</code></li>\n<li>touchmove（）----<code>触摸移动，获取到路径点</code></li>\n<li>touchend（）----<code>触摸结束，将未绘制的点清空防止对后续路径产生干扰</code></li>\n<li>draw（）----<code>绘制笔迹</code></li>\n<li>clear（）----<code>清空画布</code></li>\n<li>finish（）----<code>完成绘画并保存到本地</code></li>\n</ol>\n<pre><code class=\"copyable\">methods: {\n    createCanvas() {\n        //创建绘图对象\n        this.ctx = uni.createCanvasContext(\'mycanvas\', this);\n        //设置画笔样式\n        this.ctx.lineWidth = 4;\n        this.ctx.lineCap = \'round\';\n        this.ctx.lineJoin = \'round\';\n        },\n    touchstart(e) {\n        let startX = e.changedTouches[0].x;\n        let startY = e.changedTouches[0].y;\n        let startPoint = { X: startX, Y: startY };\n        this.points.push(startPoint);\n        //每次触摸开始，开启新的路径\n        this.ctx.beginPath();\n	},\n   touchmove(e) {\n        let moveX = e.changedTouches[0].x;\n        let moveY = e.changedTouches[0].y;\n        let movePoint = { X: moveX, Y: moveY };\n        this.points.push(movePoint); //存点\n        let len = this.points.length;\n        if (len &gt;= 2) {\n                this.draw(); //绘制路径\n        }\n	},\n   touchend() {\n        this.points = [];\n	},\n   draw() {\n        let point1 = this.points[0];\n        let point2 = this.points[1];\n        this.points.shift();\n        this.ctx.moveTo(point1.X, point1.Y);\n        this.ctx.lineTo(point2.X, point2.Y);\n        this.ctx.stroke();\n        this.ctx.draw(true);\n        },\n   clear() {\n        let that = this;\n        uni.getSystemInfo({\n                success: function(res) {\n                    let canvasw = res.windowWidth;\n                    let canvash = res.windowHeight;\n                    that.ctx.clearRect(0, 0, canvasw, canvash);\n                    that.ctx.draw(true);\n                }\n        });\n        },\n   finish() {\n        let that = this;\n        uni.canvasToTempFilePath({\n            canvasId: \'mycanvas\',\n            success: function(res) {\n                     //这里的res.tempFilePath就是生成的签字图片\n                    console.log(res.tempFilePath);\n            }\n        });\n   }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>上面<code>finish()</code>方法得到的<code>res.tempFilePath</code>就是生成出来的签名，可用于做余下的业务操作</p>\n</div>\n</div>\n</article>\n<div class=\"tag-list-box\" data-v-b7597dfc=\"\" data-v-4a869969=\"\">\n<div class=\"tag-list\" data-v-b7597dfc=\"\" data-v-4a869969=\"\">&nbsp;</div>\n</div>\n</div>\n</div>', 0, 0, 0, 0, 1, 0, NULL, NULL, NULL);
INSERT INTO `cms_article` (`id`, `status`, `description`, `createTime`, `createBy`, `updateTime`, `updateBy`, `deleteStatus`, `deleteTime`, `deleteBy`, `title`, `summary`, `author`, `source`, `keywords`, `type`, `thumbId`, `fileId`, `contentUrl`, `mediaId`, `weight`, `content`, `browseCount`, `linkCount`, `collectCount`, `shareCount`, `isComment`, `commentCount`, `publishTime`, `publishBy`, `version`) VALUES ('0a4e9f0b-9599-446b-a956-00bea0d19d0f', 1, '', '2021-08-17 00:08:09.121561', NULL, '2021-10-15 18:02:25.000000', '62310947-7b54-45c8-a5da-19837f2541a4', 0, '2021-08-23 12:51:16', '62310947-7b54-45c8-a5da-19837f2541a4', '重构指北——《重构，改善既有代码设计》精读', '', NULL, NULL, NULL, 0, '', NULL, '', '', 0, '<div>\n<blockquote>\n<p>本文总结自笔者的开发经验以及 Martin Fowler 的《重构，改善既有代码设计》读书体会，希望能帮助更多的开发者了解重构，重构并不是想象中的重活，它也可以很简单。Commit a feature，review and refactor。</p>\n</blockquote>\n<h3 data-id=\"heading-0\"><strong>1. 什么是重构</strong></h3>\n<p>这里先给重构下一个定义：改善既有代码的设计。</p>\n<p>具体来说就是在不改变代码功能行为的情况下，对其内部结构的一种调整。需要注意的是，<strong>重构不是代码优化，重构注重的是提高代码的可理解性与可扩展性，对性能的影响可好可坏</strong>。而性能优化则让程序运行的更快，当然，最终的代码可能更难理解和维护。</p>\n<h3 data-id=\"heading-1\"><strong>2. 为什么要重构</strong></h3>\n<h4 data-id=\"heading-2\"><strong>2.1. 改善程序的内部设计</strong></h4>\n<p>如果没有重构，在软件不停的版本迭代中，代码的设计只会越来越腐败，导致软件开发寸步难行。</p>\n<p>这里的原因主要有两点：</p>\n<ul>\n<li><strong>人们只为了短期目的而修改代码时，往往没有完全理解整体的架构设计（在大项目中常有这种情况，比如在不同的地方，使用完全相同的语句做着同样的事情），代码就会失去自己的结构，代码结构的流失具有累积效应，越难看出代码所代表的设计意图，就越难保护其设计。</strong></li>\n<li><strong>我们几乎不可能预先做出完美的设计，以面对后续未知的功能开发，只有在实践中才能找到真理。</strong></li>\n</ul>\n<p>所以想要体面又快速的开发功能，重构必不可少。</p>\n<h4 data-id=\"heading-3\"><strong>2.2. 使得代码更容易理解</strong></h4>\n<p>在开发中，我们需要先理解代码在做什么，才能着手修改，很多时候自己写的代码都会忘记其实现，更不论别人的代码。可能在这段代码中有一段糟糕的条件判断逻辑，又或者其变量命名实在糟糕又确实注释，需要花上好一段时间才能明白其真正用意。</p>\n<p><strong>合理的重构能让代码&ldquo;自解释&rdquo;</strong> ，以方便理解，无论对于协同开发，还是维护先前自己实现的功能，对代码的开发有着立竿见影的效果。</p>\n<h4 data-id=\"heading-4\"><strong>2.3. 提高开发的速度 &amp;&amp; 方便定位错误</strong></h4>\n<p>提高开发的速度可能有点&ldquo;反直觉&rdquo;，因为重构在很多时候看来是额外的工作量，并没有新的功能和特性产出，但是减少代码的书写量（复用模块），方便定位错误（代码结构优良），这些能让我们在开发的时候节省大量的时间，在后续的开发中&ldquo;轻装上阵&rdquo;。</p>\n<h3 data-id=\"heading-5\"><strong>3. 重构的原则</strong></h3>\n<h4 data-id=\"heading-6\"><strong>3.1. 保持当下的编程状态</strong></h4>\n<p>Kent Beck 提出了&ldquo;两顶帽子&rdquo;的比喻，在开发软件时，把自己的时间分配给两种截然不同的行为：添加新功能和重构，添加新功能的时候，不应该修改既有的代码，只管添加新功能，并让程序正确运行；在重构时就不能添加新功能，只管调整代码结构，只有在绝对必要时才能修改相关代码。</p>\n<p>在开发过程中，我们可能经常变换&ldquo;帽子&rdquo;，在新增功能的时候会意识到，如果把程序结构改一下，功能的添加会容易很多，或者实现会更加优雅，于是一会换一顶&ldquo;帽子&rdquo;，一边重构，一边新增新功能。这很容易让自己产生混乱，对自己的代码难以理解。</p>\n<p>任何时候我们都要清楚自己戴的是哪一顶&ldquo;帽子&rdquo;，并专注自己的编程状态，这让我们的目标清晰且过程可控，能对自己编码的进度有掌握。</p>\n<h4 data-id=\"heading-7\"><strong>3.2. 可控制的重构</strong></h4>\n<p>重构的过程并非一蹴而就，如果因为重构影响了自己对时间的掌控，对函数功能的掌控，那么你就应该及时停下，思考你的行为是否值得。我们必须保证程序的可用性与时间的可控性，并且要保证我们的步伐要小，确保每一步都有 git 管理和代码测试，否则你会陷入程序不可用的中间态，更可怕的是你忘记了之前代码的样子！</p>\n<p>在本文后续章节<strong>何时开始重构</strong>中会有更多这方面的介绍，这里先跳过不谈。</p>\n<h3 data-id=\"heading-8\"><strong>4. 识别代码的臭味道</strong></h3>\n<p>重构世界的规则我们已经了解，下面有一份重构指南北，是时候去回顾代码里的片段，识别它们身上的臭味并将其消灭！</p>\n<p>当然，如果觉得其中的内容过长，可跳过不看，也可匆匆略过，日后回顾也是不错的选择。</p>\n<h4 data-id=\"heading-9\"><strong>4.1. 神秘命名</strong></h4>\n<p>我承认，在侦探小说透过神秘的文字去猜测故事情节是一种很棒的体验，但在代码中，这往往让程序员困扰！需要花费大量时间去探究一个变量的作用和一个函数的功能，甚者需要在该代码片段中加入大量注释。</p>\n<p>这里并不是批评注释这种行为，而是一个优秀的代码片段和编码命名，往往能让代码自解释，减少一些不必要的注释，阅读代码如同阅读文字一样流畅。</p>\n<p>由此可见，变量命名实在是任何重构时都要第一步更正的地方，但也很遗憾的是，命名是编程中最难的几件事之一。</p>\n<ul>\n<li><strong>需要在简洁性和命名长度中平衡。</strong></li>\n<li><strong>需要统一变量命名的风格，特别是一个整个团队！因为变量命名往往不在代码风格检测之内！</strong></li>\n<li><strong>需要变量的名字既能做到彼此关联，又对其信息的识别互不干扰，想象一下，在一个代码片段中在存在着</strong> ****<code>cgi</code> ****<strong>和</strong> ****<code>cgiList</code> ****<strong>等变量，你可以直接从中读出之间的关联，若是</strong><code>cgi</code> ****<strong>和</strong> ****<code>list</code> ****<strong>呢，它们之间的联系就丢失了，又或者同时出现了</strong> ****<code>people</code> ****<strong>和</strong> ****<code>human</code> ****<strong>两个变量，这是不是让你产生了疑惑？</strong></li>\n<li><strong>需要良好的英语水平。</strong></li>\n</ul>\n<p>变量命名并没有确切细致的教程，也很难强制统一，一般符合以下三点即可。</p>\n<ul>\n<li><strong>有意义的</strong></li>\n<li><strong>相关联的</strong></li>\n<li><strong>不复用的</strong></li>\n</ul>\n<p>实践是检验质量的唯一标准，如果你的变量能够让其他同学见名知意，就说明你是正确的！</p>\n<h4 data-id=\"heading-10\"><strong>4.2. 重复代码</strong></h4>\n<p>提炼重复代码无疑是重构中最经典的手法，很多时候我们会在不同的地方写下相似的代码，又或者拷贝一份副本至当前上下文中，它们之间的差异寥寥无几。</p>\n<p>这时会出现一个很棘手的问题，当需要去修改其中的功能时，你必须找出所有的副本一一修改，这让人在阅读和修改代码时都很容易出现纰漏。所以我们要拒绝重复造轮子，尽量实现高可复用性的代码。</p>\n<p>我们可以将其抽离成一个公共函数，并以其功能作为命名。</p>\n<h4 data-id=\"heading-11\"><strong>4.3. 过长函数</strong></h4>\n<p>函数越长，就越难以理解，与之带来的还有高耦合性，不利于拆解重组。</p>\n<p>目前普遍认为代码的行数不要超出一个屏幕的范围，因为这样会造成上下滚动，会增大出错的概率。根据腾讯代码规范，一个函数的代码行数不要超出 80 行。</p>\n<p>直接看下面这两份代码，它们实现的是同样的功能，不用理解它们的含义（也没有任何含义），仅仅简单对比视觉效果，感觉如何？</p>\n<pre><code class=\"hljs language-javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">//&nbsp;重构前</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">changeList</span>(<span class=\"hljs-params\">list</span>)&nbsp;</span>{\n&nbsp;&nbsp;<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'some&nbsp;operation&nbsp;of&nbsp;list\'</span>)\n&nbsp;&nbsp;<span class=\"hljs-keyword\">for</span>&nbsp;(<span class=\"hljs-keyword\">let</span>&nbsp;i=<span class=\"hljs-number\">0</span>;&nbsp;i&lt;list.length;&nbsp;i++)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\">//&nbsp;do&nbsp;sth</span>\n&nbsp;&nbsp;}\n&nbsp;&nbsp;\n&nbsp;&nbsp;<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'conditional&nbsp;judgment\'</span>)\n&nbsp;&nbsp;<span class=\"hljs-keyword\">let</span>&nbsp;result\n&nbsp;&nbsp;<span class=\"hljs-keyword\">if</span>&nbsp;(list.length&nbsp;&lt;&nbsp;<span class=\"hljs-number\">4</span>)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;list.pop()\n&nbsp;&nbsp;}&nbsp;<span class=\"hljs-keyword\">else</span>&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;list.shift()\n&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;<span class=\"hljs-keyword\">const</span>&nbsp;today&nbsp;=&nbsp;<span class=\"hljs-keyword\">new</span>&nbsp;<span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-built_in\">Date</span>.now())\n&nbsp;&nbsp;<span class=\"hljs-keyword\">const</span>&nbsp;dueDate&nbsp;=&nbsp;<span class=\"hljs-keyword\">new</span>&nbsp;<span class=\"hljs-built_in\">Date</span>(today.getFullYear(),&nbsp;today.getMonth(),&nbsp;today.getDate()&nbsp;+&nbsp;<span class=\"hljs-number\">30</span>);\n&nbsp;&nbsp;\n&nbsp;&nbsp;result.dueDate&nbsp;=&nbsp;dueDate\n&nbsp;\n&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;result\n}\n<span class=\"hljs-comment\">//&nbsp;重构后</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">changeList</span>(<span class=\"hljs-params\">list</span>)&nbsp;</span>{\n&nbsp;&nbsp;<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'some&nbsp;operation&nbsp;of&nbsp;list\'</span>)\n&nbsp;&nbsp;operationOfList(list)\n&nbsp;&nbsp;\n&nbsp;&nbsp;<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'conditional&nbsp;judgment\'</span>)\n&nbsp;&nbsp;<span class=\"hljs-keyword\">const</span>&nbsp;result&nbsp;=&nbsp;judgment(list)\n&nbsp;&nbsp;\n&nbsp;&nbsp;result.dueDate&nbsp;=&nbsp;getRecordTime()\n&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;result\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">operationOfList</span>(<span class=\"hljs-params\">list</span>)&nbsp;</span>{\n&nbsp;&nbsp;<span class=\"hljs-keyword\">for</span>&nbsp;(<span class=\"hljs-keyword\">let</span>&nbsp;i=<span class=\"hljs-number\">0</span>;&nbsp;i&lt;list.length;&nbsp;i++)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\">//&nbsp;do&nbsp;sth</span>\n&nbsp;&nbsp;}\n&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;list\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">judgment</span>(<span class=\"hljs-params\">list</span>)&nbsp;</span>{\n&nbsp;&nbsp;<span class=\"hljs-keyword\">let</span>&nbsp;result\n&nbsp;&nbsp;<span class=\"hljs-keyword\">if</span>&nbsp;(list.length&nbsp;&lt;&nbsp;<span class=\"hljs-number\">4</span>)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;list.pop()\n&nbsp;&nbsp;}&nbsp;<span class=\"hljs-keyword\">else</span>&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;list.shift()\n&nbsp;&nbsp;}\n&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;result\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">getRecordTime</span>()&nbsp;</span>{\n&nbsp;&nbsp;<span class=\"hljs-keyword\">const</span>&nbsp;today&nbsp;=&nbsp;<span class=\"hljs-keyword\">new</span>&nbsp;<span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-built_in\">Date</span>.now())\n&nbsp;&nbsp;<span class=\"hljs-keyword\">const</span>&nbsp;dueDate&nbsp;=&nbsp;<span class=\"hljs-keyword\">new</span>&nbsp;<span class=\"hljs-built_in\">Date</span>(today.getFullYear(),&nbsp;today.getMonth(),&nbsp;today.getDate()&nbsp;+&nbsp;<span class=\"hljs-number\">30</span>);\n&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;dueDate\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>事实证明，拆分函数有利于更好更快地理解代码，以及降低耦合度，更方便地重新&ldquo;组装&rdquo;新函数。当然你也可能此时会觉得很麻烦，属于多此一举，但是重构的目标就是要保证代码的可读性。如果有一天你想要修改或增加该函数的功能，看到重构后的代码你会感谢自己的。</p>\n<h4 data-id=\"heading-12\"><strong>4.4. 数据泥团 &amp;&amp; 过长参数</strong></h4>\n<p>数据泥团（魔法数字），顾名思义就是一帮数据无规则的结合在一起，这让人对其难以把控。</p>\n<p>如果说有多个参数互相搭配，又或者说某些数据总是成群结队出现，那我们就该把这团泥塑造成一个具体的形象，将其封装成一个数据对象。</p>\n<pre><code class=\"hljs language-javascript copyable\" lang=\"javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">addUser</span>(<span class=\"hljs-params\">name,&nbsp;gender,&nbsp;age</span>)&nbsp;</span>{\n&nbsp;&nbsp;<span class=\"hljs-comment\">//&nbsp;some&nbsp;other&nbsp;codes</span>\n&nbsp;&nbsp;...\n&nbsp;&nbsp;<span class=\"hljs-comment\">//&nbsp;officeAreaCode&nbsp;与&nbsp;officeNumber&nbsp;成对出现，如果缺少&nbsp;officeNumber，那么&nbsp;officeAreaCode&nbsp;也没有意义，这里应该组合起来</span>\n&nbsp;&nbsp;clumps.officeAreaCode&nbsp;=&nbsp;<span class=\"hljs-string\">\'+86\'</span>\n&nbsp;&nbsp;clumps.officeNumber&nbsp;=&nbsp;<span class=\"hljs-number\">13688888888</span>;\n&nbsp;&nbsp;\n&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;person\n}\n\n\n<span class=\"hljs-comment\">//&nbsp;重构后</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>&nbsp;<span class=\"hljs-title\">TelephoneNumber</span>(<span class=\"hljs-title\">officeAreaCode</span>,&nbsp;<span class=\"hljs-title\">officeNumber</span>)&nbsp;</span>{\n&nbsp;&nbsp;<span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>()</span>&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\">this</span>.officeAreaCode&nbsp;=&nbsp;officeAreaCode\n&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\">this</span>.officeNumber&nbsp;=&nbsp;officeNumber\n&nbsp;&nbsp;}\n}\n<span class=\"hljs-comment\">//&nbsp;参数融合</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">addUser</span>(<span class=\"hljs-params\">person</span>)&nbsp;</span>{\n&nbsp;&nbsp;<span class=\"hljs-comment\">//&nbsp;some&nbsp;other&nbsp;codes</span>\n&nbsp;&nbsp;...\n&nbsp;&nbsp;<span class=\"hljs-comment\">//&nbsp;封装数据</span>\n&nbsp;&nbsp;person.telephone&nbsp;=&nbsp;<span class=\"hljs-keyword\">new</span>&nbsp;TelephoneNumber(<span class=\"hljs-string\">\'+86\'</span>,&nbsp;<span class=\"hljs-string\">\'13688888888\'</span>)\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 data-id=\"heading-13\"><strong>4.5. 全局数据</strong></h4>\n<p>很多时候我们都不可避免地使用全局数据，哪怕只有一个变量，全局数据对我们的管理提出了更高的要求。因为哪怕一个小小的更改，都可能引起很多地方出现问题，更可怕的是在无意间触发了这种更改。</p>\n<p>全局数据也阻碍了程序的可预测性，由于每个函数都能访问这些变量，因此越来越难弄清那个函数实际读写这些变量，要理解一个程序的工作方式，几乎必须考虑修改全局状态的每个函数，使得调试变得困难。</p>\n<p>如果不依靠全局变量，则可以根据不同函数之间传递的状态，这样以来，就能更好的了解每个功能的作用，因为你无需考虑全局变量。</p>\n<pre><code class=\"hljs language-javascript copyable\" lang=\"javascript\"><span class=\"hljs-keyword\">let</span>&nbsp;globalData&nbsp;=&nbsp;<span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-comment\">//&nbsp;bad</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">foo</span>()&nbsp;</span>{\n&nbsp;&nbsp;globalData&nbsp;=&nbsp;<span class=\"hljs-number\">2</span>\n}\n\n<span class=\"hljs-comment\">//&nbsp;bad</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">fuu</span>()&nbsp;</span>{\n&nbsp;&nbsp;globalData&nbsp;=&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attr\">a</span>:&nbsp;<span class=\"hljs-number\">1</span>\n&nbsp;&nbsp;}\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>现在，我们要对全局数据进行一些封装，控制对其的访问。</p>\n<pre><code class=\"hljs language-javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">//&nbsp;使用常量&nbsp;good</span>\n<span class=\"hljs-keyword\">const</span>&nbsp;constantData&nbsp;=&nbsp;<span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-comment\">//&nbsp;封装变量操作&nbsp;good</span>\n<span class=\"hljs-keyword\">let</span>&nbsp;globalData&nbsp;=&nbsp;<span class=\"hljs-number\">1</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">getGlobalData</span>()&nbsp;</span>{\n&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;globalData\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">setGlobalData</span>(<span class=\"hljs-params\">newGlobalData</span>)</span>{\n&nbsp;&nbsp;<span class=\"hljs-keyword\">if</span>&nbsp;(!isValid(newGlobalData))&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">throw</span>&nbsp;<span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">\'Illegal input！！！\'</span>)\n&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>\n&nbsp;&nbsp;}\n&nbsp;&nbsp;\n&nbsp;&nbsp;globalData&nbsp;=&nbsp;newGlobalData\n}\n<span class=\"hljs-comment\">//&nbsp;暴露方法</span>\n<span class=\"hljs-keyword\">export</span>&nbsp;{\n&nbsp;&nbsp;getGlobalData,\n&nbsp;&nbsp;setGlobalData\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>现在，全局变量不会轻易的被&ldquo;误触&rdquo;，也能很快定义其修改的位置和防止错误的修改。</p>\n<h4 data-id=\"heading-14\"><strong>4.6. 发散式变化</strong></h4>\n<p>当某个函数会因为不同原因在不同方向上发生变化时，发散式变化就诞生了。这听起来有点迷糊，那么就用代码来解释吧。</p>\n<pre><code class=\"hljs language-javascript copyable\" lang=\"javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">getPrice</span>(<span class=\"hljs-params\">order</span>)&nbsp;</span>{\n&nbsp;&nbsp;<span class=\"hljs-comment\">//&nbsp;获取基础价格</span>\n&nbsp;&nbsp;<span class=\"hljs-keyword\">const</span>&nbsp;basePrice&nbsp;=&nbsp;order.quantity&nbsp;*&nbsp;order.itemPrice\n&nbsp;&nbsp;<span class=\"hljs-comment\">//&nbsp;获取折扣</span>\n&nbsp;&nbsp;<span class=\"hljs-keyword\">const</span>&nbsp;quantityDiscount&nbsp;=&nbsp;<span class=\"hljs-built_in\">Math</span>.max(<span class=\"hljs-number\">0</span>,&nbsp;order.quantity&nbsp;-&nbsp;<span class=\"hljs-number\">500</span>)&nbsp;*&nbsp;order.itemPrice&nbsp;*&nbsp;<span class=\"hljs-number\">0.05</span>\n&nbsp;&nbsp;<span class=\"hljs-comment\">//&nbsp;获取运费</span>\n&nbsp;&nbsp;<span class=\"hljs-keyword\">const</span>&nbsp;shipping&nbsp;=&nbsp;<span class=\"hljs-built_in\">Math</span>.min(basePrice&nbsp;*&nbsp;<span class=\"hljs-number\">0.1</span>,&nbsp;<span class=\"hljs-number\">100</span>)\n&nbsp;&nbsp;<span class=\"hljs-comment\">//&nbsp;计算价格</span>\n&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;basePrice&nbsp;-&nbsp;quantityDiscount&nbsp;+&nbsp;shipping\n}\n\n<span class=\"hljs-keyword\">const</span>&nbsp;orderPrice&nbsp;=&nbsp;getPrice(order);\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>这个函数用于计算商品的价格，它的计算包含了基础价格 + 数量折扣 + 运费，如果基础价格的计算规则改变，我们需要修改这个函数；如果折扣规则发生改变，我们需要修改这个函数；如果运费计算规则改变了，我们还是要修改这个函数。</p>\n<p>这种修改容易造成混乱，我们当然也希望程序一旦需要修改，我们就够跳到系统的某一点，所以是时候抽离它们了。</p>\n<pre><code class=\"hljs language-javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">//&nbsp;计算基础价格</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">calBasePrice</span>(<span class=\"hljs-params\">order</span>)&nbsp;</span>{\n&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;order.quantity&nbsp;*&nbsp;order.itemPrice\n}\n<span class=\"hljs-comment\">//&nbsp;计算折扣</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">calDiscount</span>(<span class=\"hljs-params\">order</span>)&nbsp;</span>{\n&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;<span class=\"hljs-built_in\">Math</span>.max(<span class=\"hljs-number\">0</span>,&nbsp;order.quantity&nbsp;-&nbsp;<span class=\"hljs-number\">500</span>)&nbsp;*&nbsp;order.itemPrice&nbsp;*&nbsp;<span class=\"hljs-number\">0.05</span>\n}\n<span class=\"hljs-comment\">//&nbsp;计算运费</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">calShipping</span>(<span class=\"hljs-params\">basePrice</span>)&nbsp;</span>{\n&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;<span class=\"hljs-built_in\">Math</span>.min(basePrice&nbsp;*&nbsp;<span class=\"hljs-number\">0.1</span>,&nbsp;<span class=\"hljs-number\">100</span>)\n}\n<span class=\"hljs-comment\">//&nbsp;计算商品价格</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">getPrice</span>(<span class=\"hljs-params\">order</span>)&nbsp;</span>{\n&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;calBasePrice(order)&nbsp;-&nbsp;calDiscount(order)&nbsp;+&nbsp;calShipping(calBasePrice(order))\n}\n\n<span class=\"hljs-keyword\">const</span>&nbsp;orderPrice&nbsp;=&nbsp;getPrice(order)\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>虽然该函数行数不多，当其重构的过程与先前的过长函数一致，但是将各个功能抽离处理，有利于更清晰的定位问题与修改。所以过长函数拥有多重臭味道！需要及时消灭。</p>\n<h4 data-id=\"heading-15\"><strong>4.7. 霰弹式修改</strong></h4>\n<p>霰弹式修改与发散式变化听起来差异不大，实则它们是阴阳两面。霰弹式修改与重复代码有点像，当我们需要做出一点小修改时，却要去四处一个个的修正，你不仅很难找到它们，也很容易错过某个重要的修改，直至错误发生！</p>\n<pre><code class=\"hljs language-javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">//&nbsp;File&nbsp;Reading.js</span>\n<span class=\"hljs-keyword\">const</span>&nbsp;reading&nbsp;=&nbsp;{<span class=\"hljs-attr\">customer</span>:&nbsp;<span class=\"hljs-string\">\"ivan\"</span>,&nbsp;<span class=\"hljs-attr\">quantity</span>:&nbsp;<span class=\"hljs-number\">10</span>,&nbsp;<span class=\"hljs-attr\">month</span>:&nbsp;<span class=\"hljs-number\">5</span>,&nbsp;<span class=\"hljs-attr\">year</span>:&nbsp;<span class=\"hljs-number\">2017</span>}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">acquireReading</span>()&nbsp;</span>{&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;reading&nbsp;}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">baseRate</span>(<span class=\"hljs-params\">month,&nbsp;year</span>)&nbsp;</span>{\n&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\">/*&nbsp;*/</span>\n}\n\n<span class=\"hljs-comment\">//&nbsp;File&nbsp;1</span>\n<span class=\"hljs-keyword\">const</span>&nbsp;aReading&nbsp;=&nbsp;acquireReading()\n<span class=\"hljs-keyword\">const</span>&nbsp;baseCharge&nbsp;=&nbsp;baseRate(aReading.month,&nbsp;aReading.year)&nbsp;*&nbsp;aReading.quantity\n\n<span class=\"hljs-comment\">//&nbsp;File&nbsp;2</span>\n<span class=\"hljs-keyword\">const</span>&nbsp;aReading&nbsp;=&nbsp;acquireReading()\n<span class=\"hljs-keyword\">const</span>&nbsp;base&nbsp;=&nbsp;(baseRate(aReading.month,&nbsp;aReading.year)&nbsp;*&nbsp;aReading.quantity)\n<span class=\"hljs-keyword\">const</span>&nbsp;taxableCharge&nbsp;=&nbsp;<span class=\"hljs-built_in\">Math</span>.max(<span class=\"hljs-number\">0</span>,&nbsp;base&nbsp;-&nbsp;taxThreshold(aReading.year))\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">taxThreshold</span>(<span class=\"hljs-params\">year</span>)&nbsp;</span>{&nbsp;<span class=\"hljs-comment\">/*&nbsp;*/</span>&nbsp;}\n\n<span class=\"hljs-comment\">//&nbsp;File&nbsp;3</span>\n<span class=\"hljs-keyword\">const</span>&nbsp;aReading&nbsp;=&nbsp;acquireReading()\n<span class=\"hljs-keyword\">const</span>&nbsp;basicChargeAmount&nbsp;=&nbsp;calculateBaseCharge(aReading)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">calculateBaseCharge</span>(<span class=\"hljs-params\">aReading</span>)&nbsp;</span>{\n&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;baseRate(aReading.month,&nbsp;aReading.year)&nbsp;*&nbsp;aReading.quantity\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>在上面的代码中，如果&nbsp;<code>reading</code>&nbsp;的逻辑发生了改变，我们需要跨越好几个文件去调整它，这很容易造成遗漏的发生。</p>\n<p>由于每个地方都对&nbsp;<code>reading</code>&nbsp;进行了操作，那么我们可以将其封装起来，统一在一个文件中进行管理。</p>\n<pre><code class=\"hljs language-javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">//&nbsp;File&nbsp;Reading.js</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>&nbsp;<span class=\"hljs-title\">Reading</span>&nbsp;</span>{\n&nbsp;<span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">data</span>)</span>&nbsp;{\n&nbsp;&nbsp;<span class=\"hljs-built_in\">this</span>.customer&nbsp;=&nbsp;data.customer\n&nbsp;&nbsp;<span class=\"hljs-built_in\">this</span>.quantity&nbsp;=&nbsp;data.quantity\n&nbsp;&nbsp;<span class=\"hljs-built_in\">this</span>.month&nbsp;=&nbsp;data.month\n&nbsp;&nbsp;<span class=\"hljs-built_in\">this</span>.year&nbsp;=&nbsp;data.year\n&nbsp;}\n\n&nbsp;<span class=\"hljs-keyword\">get</span>&nbsp;<span class=\"hljs-title\">baseRate</span>()&nbsp;{\n&nbsp;&nbsp;<span class=\"hljs-comment\">/*&nbsp;...&nbsp;*/</span>\n&nbsp;}\n\n&nbsp;<span class=\"hljs-keyword\">get</span>&nbsp;<span class=\"hljs-title\">baseCharge</span>()&nbsp;{\n&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;baseRate(<span class=\"hljs-built_in\">this</span>.month,&nbsp;<span class=\"hljs-built_in\">this</span>.year)&nbsp;*&nbsp;<span class=\"hljs-built_in\">this</span>.quantity\n&nbsp;}\n\n&nbsp;<span class=\"hljs-keyword\">get</span>&nbsp;<span class=\"hljs-title\">taxableCharge</span>()&nbsp;{\n&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;<span class=\"hljs-built_in\">Math</span>.max(<span class=\"hljs-number\">0</span>,&nbsp;base&nbsp;-&nbsp;taxThreshold())\n&nbsp;}\n\n&nbsp;<span class=\"hljs-keyword\">get</span>&nbsp;<span class=\"hljs-title\">taxThreshold</span>()&nbsp;{\n&nbsp;&nbsp;<span class=\"hljs-comment\">/*&nbsp;...&nbsp;*/</span>\n&nbsp;}\n}\n\n<span class=\"hljs-keyword\">const</span>&nbsp;reading&nbsp;=&nbsp;<span class=\"hljs-keyword\">new</span>&nbsp;Reading({&nbsp;<span class=\"hljs-attr\">customer</span>:&nbsp;<span class=\"hljs-string\">\'Evan&nbsp;You\'</span>,&nbsp;<span class=\"hljs-attr\">quantity</span>:&nbsp;<span class=\"hljs-number\">10</span>,&nbsp;<span class=\"hljs-attr\">month</span>:&nbsp;<span class=\"hljs-number\">8</span>,&nbsp;<span class=\"hljs-attr\">year</span>:&nbsp;<span class=\"hljs-number\">2021</span>&nbsp;})\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>所有的相关逻辑在一起，不仅能提供一个共用的环境，也可以简化调用逻辑，更加清晰。</p>\n<h4 data-id=\"heading-16\"><strong>4.8. for 循环语句</strong></h4>\n<p>很惊讶，循环一直是程序中的核心要素，在这里重构的世界里居然变成了臭味道。这里并不是要将循环取缔，但仅仅使用普通的 for 循环在当下有些过时，现在我们有很好的替代品。在 JS 的世界里拥有着管道操作（filter，map 等）它们可以帮助我们更好的处理元素以及帮助我们看清处理的动作。</p>\n<p>下面我们将会从人群中挑选出所有的程序员并记录他们的名字，哪种做法更赏心悦目呢？</p>\n<pre><code class=\"hljs language-javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">//&nbsp;for</span>\n<span class=\"hljs-keyword\">const</span>&nbsp;programmerNames&nbsp;=&nbsp;[]\n<span class=\"hljs-keyword\">for</span>&nbsp;(<span class=\"hljs-keyword\">const</span>&nbsp;item&nbsp;<span class=\"hljs-keyword\">of</span>&nbsp;people)&nbsp;{\n&nbsp;&nbsp;<span class=\"hljs-keyword\">if</span>&nbsp;(item.job&nbsp;===&nbsp;<span class=\"hljs-string\">\'programmer\'</span>)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;programmerNames.push(item.name)\n&nbsp;&nbsp;}\n}\n\n<span class=\"hljs-comment\">//&nbsp;pipeline</span>\n<span class=\"hljs-keyword\">const</span>&nbsp;programmerNames&nbsp;=&nbsp;people\n&nbsp;&nbsp;.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span>&nbsp;=&gt;</span>&nbsp;item.job&nbsp;===&nbsp;<span class=\"hljs-string\">\'programmer\'</span>)\n&nbsp;&nbsp;.map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span>&nbsp;=&gt;</span>&nbsp;item.name)\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>当然，这个时候你可能会提出它们之间性能的差别，不要忘了重构的意义是为了代码更清晰，性能在这里并不是优先要考虑的事情。</p>\n<p>不过这里很也很遗憾的告诉你一个点，仅有少数的管道操作符支持逆序操作（reduce，reduceRight）,更多时候必须在之前使用 reverse 来反转数组。所以是否要取缔 for 循环，取决于你自己，也取决于实际场景。</p>\n<h4 data-id=\"heading-17\"><strong>4.9. 复杂的条件逻辑 &amp;&amp; 合并条件表达式</strong></h4>\n<p>复杂的条件逻辑是导致复杂度上升的地点之一，代码会告诉我们会发生什么事，可我们常常弄不清为什么会发生这样的事，这就证明代码的可读性大大降低了。是时候将它们封装成一个带有说明的函数了，见文知意，一目了然。</p>\n<pre><code class=\"hljs language-javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">//&nbsp;bad</span>\n<span class=\"hljs-keyword\">if</span>&nbsp;(!date.isBefore(plan.summberStart)&nbsp;&amp;&amp;&nbsp;!date.isAfter(plan.summberEnd))&nbsp;{\n&nbsp;&nbsp;charge&nbsp;=&nbsp;quantity&nbsp;*&nbsp;plan.summerRate\n}&nbsp;<span class=\"hljs-keyword\">else</span>&nbsp;{\n&nbsp;&nbsp;charge&nbsp;=&nbsp;quantity&nbsp;*&nbsp;plan.regularRate&nbsp;+&nbsp;plan.regularServiceCharge\n}\n\n\n<span class=\"hljs-comment\">//&nbsp;good</span>\n<span class=\"hljs-keyword\">if</span>&nbsp;(isSummer())&nbsp;{\n&nbsp;&nbsp;charge&nbsp;=&nbsp;quantity&nbsp;*&nbsp;plan.summerRate\n}&nbsp;<span class=\"hljs-keyword\">else</span>&nbsp;{\n&nbsp;&nbsp;charge&nbsp;=&nbsp;quantity&nbsp;*&nbsp;plan.regularRate&nbsp;+&nbsp;plan.regularServiceCharge\n}\n\n<span class=\"hljs-comment\">//&nbsp;perfect</span>\nisSummer()&nbsp;?&nbsp;summerCharge()&nbsp;:&nbsp;regularCharge()\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>如果一串条件检查，检查条件各不相同，最终行为却一致，那么我们就应该使用逻辑或和逻辑与将他们合并成为一个条件表达式。然后再做上面代码的逻辑，封装！</p>\n<pre><code class=\"hljs language-javascript copyable\" lang=\"javascript\"><span class=\"hljs-keyword\">if</span>&nbsp;(man.age&nbsp;&lt;&nbsp;<span class=\"hljs-number\">18</span>)&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;<span class=\"hljs-number\">0</span>\n<span class=\"hljs-keyword\">if</span>&nbsp;(man.hasHeartDisease)&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;<span class=\"hljs-number\">0</span>\n<span class=\"hljs-keyword\">if</span>&nbsp;(!isFull)&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;<span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-comment\">//&nbsp;step&nbsp;1</span>\n<span class=\"hljs-keyword\">if</span>&nbsp;(man.age&nbsp;&lt;&nbsp;<span class=\"hljs-number\">18</span>&nbsp;&amp;&amp;&nbsp;man.hasHeartDisease&nbsp;&amp;&amp;&nbsp;!isFull)&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;<span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-comment\">//&nbsp;step&nbsp;2</span>\n<span class=\"hljs-keyword\">if</span>&nbsp;(isIlegalEntry(man)&nbsp;&amp;&amp;&nbsp;!isFull)&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;<span class=\"hljs-number\">0</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 data-id=\"heading-18\"><strong>4.10. 查询函数与修改函数耦合</strong></h4>\n<p>如果某个函数只是提供一个值，没有任何副作用，这是一个很有价值的东西，我可以任意调用这个函数没有后顾之忧，也可以随意的搬迁该函数。总而言之，需要操心的事情少多了。</p>\n<p>明确的分离&ldquo;有副作用&rdquo;和&ldquo;无副作用&rdquo;两种函数是一个很好的想法，查询函数和修改函数搭配在平常的开发中也经常出现，是时候将它们分离了！</p>\n<pre><code class=\"hljs language-javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">//&nbsp;给&nbsp;2&nbsp;鹅岁以下的五星员工发邮件鼓励</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">getTotalAdnSendEmail</span>()&nbsp;</span>{\n&nbsp;&nbsp;<span class=\"hljs-keyword\">const</span>&nbsp;emailList&nbsp;=&nbsp;programmerList\n&nbsp;&nbsp;&nbsp;&nbsp;.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span>&nbsp;=&gt;</span>&nbsp;item.occupationalAge&nbsp;&lt;=&nbsp;<span class=\"hljs-number\">2</span>&nbsp;&amp;&amp;&nbsp;item.stars&nbsp;===&nbsp;<span class=\"hljs-number\">5</span>)\n&nbsp;&nbsp;&nbsp;&nbsp;.map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span>&nbsp;=&gt;</span>&nbsp;item.email)\n&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;sendEmail(emailList)\n}\n\n<span class=\"hljs-comment\">//&nbsp;分离查询函数，这里可以通过传递参数进一步控制查询的语句</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">search</span>()&nbsp;</span>{\n&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;programmerList\n&nbsp;&nbsp;&nbsp;&nbsp;.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span>&nbsp;=&gt;</span>&nbsp;item.occupationalAge&nbsp;&lt;=&nbsp;<span class=\"hljs-number\">2</span>&nbsp;&amp;&amp;&nbsp;item.stars&nbsp;===&nbsp;<span class=\"hljs-number\">5</span>)\n&nbsp;&nbsp;&nbsp;&nbsp;.map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span>&nbsp;=&gt;</span>&nbsp;item.email)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">send</span>()&nbsp;</span>{\n&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;sendEmail(search())\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>这样可以更好的控制查询行为以及复用函数，我们需要在一个函数内操心的事情又少了一些。</p>\n<h4 data-id=\"heading-19\"><strong>4.11. 以卫语句(Guard Clauses)取代嵌套条件表达式</strong></h4>\n<p>直接上代码</p>\n<pre><code class=\"hljs language-javascript copyable\" lang=\"javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">getPayAmount</span>()&nbsp;</span>{\n&nbsp;&nbsp;<span class=\"hljs-keyword\">let</span>&nbsp;result\n&nbsp;&nbsp;<span class=\"hljs-keyword\">if</span>&nbsp;(isDead)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\">//&nbsp;do&nbsp;sth&nbsp;and&nbsp;assign&nbsp;to&nbsp;result</span>\n&nbsp;&nbsp;}&nbsp;<span class=\"hljs-keyword\">else</span>&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">if</span>&nbsp;(isSeparated)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\">//&nbsp;do&nbsp;sth&nbsp;and&nbsp;assign&nbsp;to&nbsp;result</span>\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class=\"hljs-keyword\">else</span>&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">if</span>&nbsp;(isRetired)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\">//&nbsp;do&nbsp;sth&nbsp;and&nbsp;assign&nbsp;to&nbsp;result</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class=\"hljs-keyword\">else</span>&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\">//&nbsp;do&nbsp;sth&nbsp;and&nbsp;assign&nbsp;to&nbsp;result</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;}\n&nbsp;&nbsp;\n&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;result\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>在阅读该函数时，是否庆幸在 if else 之间的并非代码而是一段注释，如果是一段代码，则让人目眩眼花。那下面的代码呢？</p>\n<pre><code class=\"hljs language-javascript copyable\" lang=\"javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">getPayAmount</span>()&nbsp;</span>{\n&nbsp;&nbsp;<span class=\"hljs-keyword\">if</span>&nbsp;(isDead)&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;deatAmount()\n&nbsp;&nbsp;<span class=\"hljs-keyword\">if</span>&nbsp;(isSeparated)&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;serparateAmount()\n&nbsp;&nbsp;<span class=\"hljs-keyword\">if</span>&nbsp;(isRetired)&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;retiredAmount()\n&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;normalPayAmount()\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>卫语句的精髓就是给予某条分支特别的重视，它告诉阅读者，这种情况并不是本函数的所关心的核心逻辑，如果它真的发生了，会做一些必要的工作然后提前退出。</p>\n<p>我相信每个程序员都会听过&ldquo;每个函数只能有一个入口和一个出口&rdquo;这个观念，但&ldquo;单一出口&rdquo;原则在这里似乎不起作用，在重构的世界中，保证代码清晰才是最关键的。如果&ldquo;单一出口&rdquo;能让代码更易读，那么就使用它吧，否则就不必这么做。</p>\n<p>卫语句的精髓就是给予某条分支特别的重视，它告诉阅读者，这种情况并不是本函数的所关心的核心逻辑，如果它真的发生了，会做一些必要的工作然后提前退出。</p>\n<p>我相信每个程序员都会听过&ldquo;每个函数只能有一个入口和一个出口&rdquo;这个观念，但&ldquo;单一出口&rdquo;原则在这里似乎不起作用，在重构的世界中，保证代码清晰才是最关键的。如果&ldquo;单一出口&rdquo;能让代码更易读，那么就使用它吧，否则就不必这么做。</p>\n<h3 data-id=\"heading-20\"><strong>​5. 何时开始重构</strong></h3>\n<h4 data-id=\"heading-21\"><strong>5.1. 添加新功能之前</strong></h4>\n<p><strong>重构的最佳时机是在添加新功能之前</strong>。</p>\n<p>在动手添加新功能之前，看看现有的代码库，此时经常会发现，如果对代码结构做一点微调，自己的工作会轻松很多。比如有个函数提供了需要的大部分功能，但有几个字面量的值与自己的需求不同。如果不做重构，需要复制整个函数再进行微调，这导致重复代码的产生，这是代码臭味道的开始。所以需要戴上重构的&ldquo;帽子&rdquo;，做完这件事后，再轻松的开发你的功能。</p>\n<p>但这也是在理想情况下的设想，事实上任务的安排总有时间限制，多出一段的重构的耗时可能会让你对时间的安排失控，导致延期，所以对于工作中的场景，并不适用。</p>\n<h4 data-id=\"heading-22\"><strong>5.2. 完成新功能后或 code review 后</strong></h4>\n<p><strong>结合任务的排期和实际的工作，重构的最佳时机是在完成一个功能后和 code review 后</strong>。</p>\n<p>在完成功能并测试通过后，此时对任务的进度是可控的，重构不会影响到代码既有实现的功能，在使用 git 等版本控制系统管理的情况下，回退至功能可用时的代码片段是非常轻易的，但你无法立即完成你从未实现好的功能。</p>\n<p>在每完成一个功能后重构，也类似于垃圾回收中的时间分片的思想，不必等到代码中塞满&ldquo;垃圾&rdquo;时才开始清理，导致&ldquo;全停顿&rdquo;的发生。将重构分解为一小步一小步。</p>\n<p>让一个团队，特别是共同实现同一项目的团队来校验自己的代码，往往能够发现自己难以注意的问题。比如自己写的一个功能其实另一个同学已经实现过了，完全可以抽离出来复用；比如有经验的同学提出更加优雅的实现方案。</p>\n<p>并且自己编写的代码往往带有自己的风格和&ldquo;坏习惯&rdquo;，代码风格并不是一种错误，但在一个团队中，不同代码风格的混杂会带来阅读与合作的困难，而对于&ldquo;坏习惯&rdquo;而言，比如极其复杂的条件判断语句等，自己难以意识到该做法的不妥，需要群众的意见加以改正。</p>\n<p>实际上在每完成一个新功能后重构还有一些笔者认为很重要的优势，就是你会对自己的代码有更清晰的了解，你会去做<strong>今后不会再做的事情</strong>。</p>\n<p>对代码更清晰，能让我们更好的定位问题和提高自己的代码水平，这很好理解。</p>\n<p>那这个<strong>今后不会再做的事情</strong>是什么呢？没错，就是重构。当你完成新功能后，如果不立刻进行 review，那么在上线后很可能就从此被封存在某个地方，直到它出现了 bug。久而久之，整个项目变得难以维护，代码开始发臭。</p>\n<p>而在完成新功能后重构，工作量一般也不会很大，是&ldquo;顺手完成的小工作&rdquo;，属于一鼓作气阶段，如果打算以后再看，那么往往就没有这个以后了。</p>\n<h4 data-id=\"heading-23\"><strong>5.3. 难以添加新功能的时候</strong></h4>\n<p>其实并不希望这个状况发生，这代表代码结构已经处于混乱中，添加新功能需要翻越好几个障碍。此时重构是个必选项，也必然是个大工程，这会造成项目的&ldquo;全停顿&rdquo;。更糟糕的是此时重构可能不如直接重写，这是我们需要避免的情况。</p>\n<h3 data-id=\"heading-24\"><strong>6. 什么时候不该重构</strong></h3>\n<h4 data-id=\"heading-25\"><strong>6.1. 重写比重构容易</strong></h4>\n<p>这个无需多言。</p>\n<h4 data-id=\"heading-26\"><strong>6.2. 不需要理解该代码片段时</strong></h4>\n<p>如果一个功能或者 API 一直以来&ldquo;兢兢业业&rdquo;，从未出现过 bug，即便其底下隐藏着十分丑陋的代码，那么我们也可以忍受它继续保持丑陋。不要忘了重构的初衷，其中之一就是为了让人更好的理解代码，当我们不需要理解其时，就让它安安静静地躺在哪儿吧，不要让不可控制的行为发生是重构的原则之一。</p>\n<h4 data-id=\"heading-27\"><strong>6.3. 未与合作者商量时</strong></h4>\n<p>如果一个功能被多个模块引用，而这些模块并非你负责时，你必须提前通知负责人，声明将要对这部分功能进行修改，哪怕重构不会带来任何使用上的变化，因为这也意味着重构行为将会带来&ldquo;不可控&rdquo;。</p>\n<h3 data-id=\"heading-28\"><strong>7. 重构与性能</strong></h3>\n<p>关于重构对性能的影响，是被提及最多的问题。毕竟重构代码很多时候都带来了运行代码行数的增加（并不一定是代码总行数增加，因为重构有提炼函数的部分，优秀的重构总会带来代码总行数的下降）。又或者说将一些性能好的代码变为可读性更高的代码，牺牲掉性能优势。</p>\n<p>首先需要回顾一下，代码重构和性能优化是两个不同的概念，重构仅仅只考虑代码的可理解性和可拓展性，对于代码的执行效率是不在乎的，在重构时切记不要同时戴着&ldquo;两顶帽子&rdquo;。</p>\n<p>而重构对于性能的影响，也很可能没有你想象中的那么高，在面对大部分的业务情况时，重构前和重构后代码的性能差别几乎难以体现。</p>\n<p>大部分情况下，我们不需要极致的&ldquo;压榨&rdquo;计算机，来减少使用的微乎其微的计算机时钟周期时间，更重要的是，减少自己在开发中使用的时间。</p>\n<p>如果对于重构后的的性能不满意，可以在完成重构后有的放矢的对部分高耗时功能进行代码优化。一件很有趣的事情是：大多数程序运行的大半时间都在一小部分代码身上，只要优化这部分代码，就能带来显著的性能提高。如果你一视同仁的优化所有代码，就会发现这是在白费劲，因为被优化的代码不会被经常执行。</p>\n<p>所以我认为重构时大可不必为性能过多担忧，可以放手去重构，如有必要再针对个别代码片段优化。短期来看，重构的确可能使软件变慢，但重构也使性能调优更容易，最终还是会得到很好的效果。</p>\n<h3 data-id=\"heading-29\"><strong>8. 完结撒花</strong></h3>\n<p>笔者并非&ldquo;重构大师&rdquo;，本文也只展现了一些十分常见的重构手法以及对重构浅略的思考，还有很多经典的手法与案例，本文未于展示，读者如果对重构感兴趣，想深入了解的话，可以阅读 Martin Fowler 的经典书籍《重构，改善既有代码的设计 第二版》，其中的示例语言选用了 JavaScript，这简直是前端工程师的福音。</p>\n<p>对于 VSCode 用户而言，有很多优秀的插件帮助你重构，比如 JavaScript Booster 或 Stepsize，这些插件能提示你如何重构且为代码添加书签和报告。</p>\n<p>都读到这了，接下来知道该怎么做了吧。Commit a feature，review and refactor。</p>\n<h3 data-id=\"heading-30\">9. 引用</h3>\n<p>[0] 《重构，改善既有代码的设计 第二版》Martin Fowler</p>\n<p>[1]&nbsp; <a title=\"https://juejin.cn/post/6973780556664438820\" href=\"https://juejin.cn/post/6973780556664438820\" target=\"_blank\" rel=\"noopener\">代码中常见的 24 种坏味道及重构手法</a></p>\n<p>[2]&nbsp; <a title=\"https://segmentfault.com/a/1190000040435457\" href=\"https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000040435457\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">vscode中6个好用的前端重构插件</a></p>\n</div>', 0, 1, 1, 0, 1, 0, '2021-09-23 11:04:55', '62310947-7b54-45c8-a5da-19837f2541a4', NULL);
INSERT INTO `cms_article` (`id`, `status`, `description`, `createTime`, `createBy`, `updateTime`, `updateBy`, `deleteStatus`, `deleteTime`, `deleteBy`, `title`, `summary`, `author`, `source`, `keywords`, `type`, `thumbId`, `fileId`, `contentUrl`, `mediaId`, `weight`, `content`, `browseCount`, `linkCount`, `collectCount`, `shareCount`, `isComment`, `commentCount`, `publishTime`, `publishBy`, `version`) VALUES ('0bc92a85-5f18-41df-9c2c-7c8fdfff3a62', 0, '', '2021-08-17 00:07:12.836786', NULL, '2021-09-24 16:19:49.000000', NULL, 0, NULL, NULL, 'canvas也能实现事件系统？？？？', '', NULL, NULL, NULL, 0, '', NULL, '', '', 0, '', 0, 0, 0, 0, 1, 0, NULL, NULL, NULL);
INSERT INTO `cms_article` (`id`, `status`, `description`, `createTime`, `createBy`, `updateTime`, `updateBy`, `deleteStatus`, `deleteTime`, `deleteBy`, `title`, `summary`, `author`, `source`, `keywords`, `type`, `thumbId`, `fileId`, `contentUrl`, `mediaId`, `weight`, `content`, `browseCount`, `linkCount`, `collectCount`, `shareCount`, `isComment`, `commentCount`, `publishTime`, `publishBy`, `version`) VALUES ('16eda59a-2953-453b-aac0-0bba030d57c6', 1, '', '2021-08-07 01:50:50.596936', NULL, '2021-09-24 16:19:49.000000', NULL, 0, NULL, NULL, '看完还不懂JavaScript执行机制(EventLoop)，你来捶我', '这是我参与8月更文挑战的第6天，活动详情查看：8月更文挑战', NULL, NULL, NULL, 0, '', NULL, '', '', 0, '<div>\n<p>上一篇文章介绍了进程与线程，知道渲染进程都有一个主线程，并且主线程工作很多，要处理DOM、计算样式、布局、还有鼠标、键盘等各种JS任务</p>\n<p>我们都知道JS是单线程，任务只能一件一件地执行，那么浏览器是怎么让这么多类型的任务在主线程上有条紊地执行的呢？</p>\n<p>这就需要<strong>任务队列</strong>和<strong>事件循环</strong>了</p>\n<h2 data-id=\"heading-0\">任务队列(消息队列)</h2>\n<p>什么是任务队列呢？</p>\n<p>它是一种数据结构，存放要执行的任务。然后事件循环系统再以先进先出原则按顺序执行队列中的任务。产生新任务时IO线程就将任务添加在队列尾部，要执行任务渲染主线程就会循环地从队列头部取出执行，如图</p>\n<p><img class=\"medium-zoom-image\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b00d4477e9c4bca8d2268c4ceca8a9b~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"未标题-12.jpg\" /></p>\n<p>如果其他进程也有任务想让主线程执行的话，也是一样的通过 IO 线程接收并将任务添加到任务队列就可以了</p>\n<p>可任务队列里的任务类型太多了，而且是多个线程操作同一个任务队列，比如鼠标滚动、点击、移动、输入、计时器、WebSocket、文件读写、解析DOM、计算样式、计算布局、JS执行.....</p>\n<p>这些任务都在主线程中执行，而JS是单线程的，一个任务执行需要等前面的任务都执行完，所以就需要解决单个任务占用主线程过久的问题</p>\n<p>比如如果一个动画任务前面有一个JS任务执行时间很长，那我们看到的就是卡卡的感觉，用户体验就很不好</p>\n<p>如果是DOM频繁发生变化的JS任务，每次变化都需要调用相应的JavaScript接口，无疑会导致任务时间拉长，如果把DOM变化做成异步任务，那可能添加到任务队列过程中，前面又有很多任务在排队了</p>\n<p>所以<code>为了处理高优先级的任务</code>，<code>和解决单任务执行过长的问题</code>，所以需要将任务划分，所以微任务和宏任务它来了</p>\n<p>在说微任务之前，要知道一个概念就是<strong>同步</strong>和<strong>异步</strong></p>\n<h2 data-id=\"heading-1\">同步和异步</h2>\n<p>我们知道了浏览器页面是由任务队列和事件循环系统来驱动的，但是队列要一个一个执行，如果某个任务(http请求)是个耗时任务，那浏览器总不能一直卡着，所以为了防止主线程阻塞，JavaScript 又分为同步任务和异步任务</p>\n<p><code>同步任务</code>：就是任务一个一个执行，如果某个任务执行时间过长，后面的就只能一直等下去</p>\n<p><code>异步任务</code>：就是进程在执行某个任务时，该任务需要等一段时间才能返回，这时候就把这个任务放到专门处理异步任务的模块，然后继续往下执行，不会因为这个任务而阻塞</p>\n<p><strong>也就是说，除了任务队列，还有一个专门处理需要延迟执行的模块(延迟哈希表)</strong></p>\n<p><strong>常见的异步任务</strong>：定时器、ajax、事件绑定、回调函数、async await、promise</p>\n<p>好了，我们再来说微任务吧</p>\n<h2 data-id=\"heading-2\">微任务和宏任务</h2>\n<p>JS执行时，V8会创建一个全局执行上下文，在创建上下文的同时，<strong>V8也会在内部创建一个微任务队列</strong></p>\n<p><strong>有微任务队列，自然就有宏任务队列，任务队列中的每一个任务则都称为宏任务，在当前宏任务执行过程中，如果有新的微任务产生，就添加到微任务队列中</strong></p>\n<ul>\n<li><code>微任务包括</code>： promise回调、proxy、MutationObserver(监听DOM)、node 中的 process.nextTick等</li>\n<li><code>宏任务包括</code>： 渲染事件、请求、script、setTimeout、setInterval、Node中的setImmediate、I/O 等</li>\n</ul>\n<p><strong>来看栗子搞懂她</strong></p>\n<p>你和一个大爷在银行办业务，大爷排在你前面，大爷是要存钱，存完钱之后，工作人员问大爷还要不要办理其他业务，大爷说那我再改个密码吧，这时候总不能让大爷到队伍最后去排队再来改密码吧</p>\n<p>这里面大爷要办业务就是一个宏任务，而在钱存完了又想改密码，这就产生了一个微任务，大爷还想办其他业务就又产生新微任务，直到所有微任务执行完，队伍的下一个人再来</p>\n<p>这个队伍就是任务队列，工作人员就是单线程的JS引擎，排队的人只能一个一个来让他给你办事</p>\n<p>也就是说<code>当前宏任务里的微任务全部执行完，才会执行下一个宏任务</code></p>\n<p><strong>用代码来举例</strong></p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">&lt;script&gt; <span class=\"hljs-comment\">// 宏任务</span>\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">()=&gt;</span>{ <span class=\"hljs-comment\">// 宏任务</span>\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>)\n    },<span class=\"hljs-number\">0</span>)\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>)\n&lt;/script&gt;\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>输出结果就是 <code>1  3  2</code> ，因为setTimeout是宏任务，哪怕它的时间为0，当前宏任务里的任务没执行完，她插队也没用。然后就算计时时间为0，它也是一个延迟任务，所以放到异步处理模块去先</p>\n<p><strong>注意</strong>：异步处理模块(延迟哈希表)是一个和任务队列同等级的数据结构。每个宏任务结束后，主线程就会检查延迟哈希表，将里面到期的任务拿出来依次执行，比如回调/计时器达到触发条件等。不明白的话下面有图，看着就很清晰了</p>\n<p><strong>再来</strong></p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">&lt;script&gt; <span class=\"hljs-comment\">// 宏任务</span>\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> {\n        resolve(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 回调 是微任务</span>\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>)\n    }).then( <span class=\"hljs-function\"><span class=\"hljs-params\">num</span> =&gt;</span> {\n        <span class=\"hljs-built_in\">console</span>.log(num)\n    })\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">4</span>)\n&lt;/script&gt;\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>输出结果就是 <code>1 3 4 2</code> ，遇到微任务(这里的回调)就放到微任务队列里，等着执行栈中的任务执行完，再拿出来执行</p>\n<p><strong>看图，必须要搞懂她</strong></p>\n<p><img class=\"medium-zoom-image\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25681734818441f7a16ea6cdc0e0bbc3~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"367e4062e66b2c2512768749e533393.jpg\" /></p>\n<p>没理解的话可以多看一会儿这个图，这一块儿也是面试很爱问的</p>\n<p>如图可以看出来执行过程形成了一个循环，这就是<strong>事件循环( EventLoop )</strong></p>\n<h2 data-id=\"heading-3\">事件循环( <code>EventLoop</code> )</h2>\n<p>事件循环：一句话概括就是入栈到出栈的循环</p>\n<p>即：一个宏任务，所有微任务，渲染，一个宏任务，所有微任务，渲染.....</p>\n<p><strong>循环过程</strong>：</p>\n<ol>\n<li>\n<p>所有同步任务都在主线程上依次执行，形成一个执行栈(调用栈)，异步任务处理完后则放入一个任务队列</p>\n</li>\n<li>\n<p>当执行栈中任务执行完，再去检查微任务队列里的微任务是否为空，有就执行，如果执行微任务过程中又遇到微任务，就添加到微任务队列末尾继续执行，把微任务全部执行完</p>\n</li>\n<li>\n<p>微任务执行完后，再到任务队列检查宏任务是否为空，有就取出最先进入队列的宏任务压入执行栈中执行其同步代码</p>\n</li>\n<li>\n<p>然后回到第2步执行该宏任务中的微任务，如此反复，直到宏任务也执行完，如此循环</p>\n</li>\n</ol>\n<h2 data-id=\"heading-4\">练习一下，彻底搞懂她</h2>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">&lt;script&gt;\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> () </span>{\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'setTimeout\'</span>)\n    }, <span class=\"hljs-number\">0</span>)\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve</span>) </span>{\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'promise1\'</span>)\n        <span class=\"hljs-keyword\">for</span>( <span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; i++ ) {\n            i === <span class=\"hljs-number\">999</span> &amp;&amp; resolve()\n        }\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'promise2\'</span>)\n    }).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> ()  </span>{\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'promise3\'</span>)\n    })\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'script\'</span>)\n&lt;/script&gt;\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>输出结果：<code>promise1</code> -&gt; <code>promise2</code> -&gt; <code>script</code> -&gt; <code>promise3</code> -&gt; <code>setTimeout</code></p>\n<p><strong>想一下为什么？</strong></p>\n<ul>\n<li>script 是宏任务，先执行它里面的微任务</li>\n<li>遇到宏任务setTimeout放到异步处理模块(延迟哈希表)</li>\n<li>继续执行promise，打印<code>promise1</code></li>\n<li>遇到循环，执行，遇到回调 resolve()，上面说了回调属于微任务，放到微任务队列</li>\n<li>继续执行，打印 <code>promise2</code></li>\n<li>继续执行，打印 <code>script</code></li>\n<li>执行栈的任务执行完了，去微任务列队里拿</li>\n<li>有一个 then 回调，执行，打印 <code>promise3</code></li>\n<li>微任务都执行完了，去任务队列拿下一个宏任务</li>\n<li>执行 setTimeout，打印 <code>setTimeout</code></li>\n</ul>\n<p>没有理解的话，再想想</p>\n<h3 data-id=\"heading-5\">当遇到 async / await 呢？</h3>\n<p><code>async</code>/<code>await</code> 是 ES7 引入的重大改进的地方，<strong>可以在不阻塞主线程的情况下，使用同步代码实现异步访问资源的能力</strong>，让我们的代码逻辑更清晰</p>\n<p>说白了</p>\n<p><code>async</code>：就是异步执行和隐式返回Promise<br /><code>await</code>：返回的就是一个Promise对象</p>\n<p><strong>看题</strong></p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fun</span>() </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)\n    <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-number\">2</span>\n    <span class=\"hljs-built_in\">console</span>.log(a)\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>)\n}\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">4</span>)\nfun()\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">5</span>)\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>输出结果：<code>4 1 5 2 3</code></p>\n<p>结合 async / await 的特点，我们来把这个题用 ES6 翻译一下</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fun</span>()</span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">() =&gt;</span> {\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)\n        <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-number\">2</span>).then( <span class=\"hljs-function\"><span class=\"hljs-params\">a</span> =&gt;</span> {\n            <span class=\"hljs-built_in\">console</span>.log(a)\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>)\n        })\n    })\n}\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">4</span>)\nfun()\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">5</span>)\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>上面说了，回调是微任务，所以直接扔到微任务队列等着，这题里自然就是最后执行，是不是好理解一点了</p>\n<p><strong>再来</strong></p>\n<p>先别看下面答案，想一下这题，和上面有一点点区别</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span> () </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>)\n}\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fun</span>() </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)\n    <span class=\"hljs-keyword\">await</span> bar()\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>)\n}\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">4</span>)\nfun()\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">5</span>)\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>输出结果：<code>4 1 2 5 3</code></p>\n<p>为啥？上面例子中 2 都没打印出来，为啥这个就出来了</p>\n<p>因为await的意思就是等，等await后面的执行完。所以\"await bar()\"，是从右向左执行，执行完bar()，然后遇到await，返回一个微任务(哪怕这任务里没东西)，放到微任务队列让出主线程。</p>\n<p>上面说了 async/await 就是把异步以同步的形式实现，同步就是一步一步一行一行来嘛，await在微任务队列里都没回来，那在await下面的自然不能执行，导致 3 最后打印</p>\n<p>下面还有一题，把上面几题结合了，我就不写答案了</p>\n<h3 data-id=\"heading-6\">你来搞定她</h3>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">async1</span> ()  </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'async1 start\'</span>);\n    <span class=\"hljs-keyword\">await</span>  async2();\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'async1 end\'</span>)\n}\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>  <span class=\"hljs-title\">async2</span> ()  </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'async2\'</span>)\n}\n\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'script start\'</span>);\n\n<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> ()  </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'setTimeout\'</span>)\n},  <span class=\"hljs-number\">0</span>);\n\nasync1();\n\n<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve</span>)  </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'promise1\'</span>);\n    resolve()\n}).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> ()  </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'promise2\'</span>)\n});\n\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'script end\'</span>)\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 data-id=\"heading-7\">结语</h2>\n<p>点赞支持、手留余香、与有荣焉</p>\n<p>感谢你能看到这里，加油哦！</p>\n<h2 data-id=\"heading-8\">参考</h2>\n<p><a title=\"https://time.geekbang.org/column/intro/216\" href=\"https://link.juejin.cn?target=https%3A%2F%2Ftime.geekbang.org%2Fcolumn%2Fintro%2F216\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">浏览器工作原理与实践</a></p>\n</div>', 0, 0, 0, 0, 1, 0, NULL, NULL, NULL);
INSERT INTO `cms_article` (`id`, `status`, `description`, `createTime`, `createBy`, `updateTime`, `updateBy`, `deleteStatus`, `deleteTime`, `deleteBy`, `title`, `summary`, `author`, `source`, `keywords`, `type`, `thumbId`, `fileId`, `contentUrl`, `mediaId`, `weight`, `content`, `browseCount`, `linkCount`, `collectCount`, `shareCount`, `isComment`, `commentCount`, `publishTime`, `publishBy`, `version`) VALUES ('357bc0ac-b8aa-4f62-960e-83ba07e5e45a', 2, '', '2021-08-17 00:08:33.276649', NULL, '2021-09-24 16:19:49.000000', '518e81b2-0bda-4729-be21-d25c94a424ff', 0, NULL, NULL, '代码中常见的 24 种坏味道及重构手法', '', NULL, NULL, NULL, 0, '', '0dec5f5e-0c48-4395-b920-18e36e27000f,34aece39-dd3d-497c-8f74-4fc5fab8e368', '', '', 0, '', 0, 0, 0, 0, 1, 0, NULL, NULL, NULL);
INSERT INTO `cms_article` (`id`, `status`, `description`, `createTime`, `createBy`, `updateTime`, `updateBy`, `deleteStatus`, `deleteTime`, `deleteBy`, `title`, `summary`, `author`, `source`, `keywords`, `type`, `thumbId`, `fileId`, `contentUrl`, `mediaId`, `weight`, `content`, `browseCount`, `linkCount`, `collectCount`, `shareCount`, `isComment`, `commentCount`, `publishTime`, `publishBy`, `version`) VALUES ('67bf1bb4-7281-48b0-835c-7e727991f5de', 0, '', '2021-08-17 00:02:26.532817', NULL, '2021-09-24 16:19:49.000000', NULL, 0, NULL, NULL, '百万PV商城实践系列 - 前端长列表渲染优化实战', '百万PV商城实践系列 - 前端长列表渲染优化实战', NULL, NULL, NULL, 0, '', NULL, '', '', 0, '<div>\n<h2 data-id=\"heading-0\">简介</h2>\n<p>本篇文章是<code>商城实践系列</code>的第二篇文章，主要内容是对商城项目中一些<code>长列表渲染</code>进行优化，提高渲染的效率、优化显示速度。</p>\n<p>我们在使用电商平台的过程中，打开首页时，我们一直向下滑动就会有源源不断的推荐内容向我们展示。随着浏览页面操作越来越多，数据也越来越庞大，这类场景我们都可以统一称为长列表渲染。</p>\n<p>在商城项目当中，长列表渲染出现的页面都与用户密切相关，如<code>订单列表</code>、<code>优惠券列表</code>、<code>购物车</code>等都是我们日常生活中经常浏览的一些页面，因此长列表渲染的<code>性能效率</code>与<code>用户体验</code>两者是成<code>正比</code>的。</p>\n</div>', 0, 0, 0, 0, 1, 0, NULL, NULL, NULL);
INSERT INTO `cms_article` (`id`, `status`, `description`, `createTime`, `createBy`, `updateTime`, `updateBy`, `deleteStatus`, `deleteTime`, `deleteBy`, `title`, `summary`, `author`, `source`, `keywords`, `type`, `thumbId`, `fileId`, `contentUrl`, `mediaId`, `weight`, `content`, `browseCount`, `linkCount`, `collectCount`, `shareCount`, `isComment`, `commentCount`, `publishTime`, `publishBy`, `version`) VALUES ('7483bae5-ce55-48fe-afc6-d14a13a20ad1', 1, '', '2021-08-07 01:49:38.827024', NULL, '2021-09-24 16:19:49.000000', NULL, 0, NULL, NULL, '前端万字面经——进阶篇', '这是我参与8月更文挑战的第2天，活动详情查看:8月更文挑战', NULL, NULL, NULL, 0, '', NULL, '', '', 0, '<h3 data-id=\"heading-1\">JSONP 的缺点</h3>\n<ul>\n<li>JSON 只支持get，因为script 标签只能使用get 请求；</li>\n<li>JSONP 需要后端配合返回指定格式的数据。</li>\n</ul>\n<h3 data-id=\"heading-2\">跨域（jsonp，ajax）</h3>\n<p>JSONP：ajax 请求受同源策略影响，不允许进行跨域请求，而script 标签src 属性中的链 接却可以访问跨域的js 脚本，利用这个特性，服务端不再返回JSON 格式的数据，而是 返回一段调用某个函数的js 代码，在src 中进行了调用，这样实现了跨域。</p>\n<h3 data-id=\"heading-3\">如何实现跨域</h3>\n<ul>\n<li>JSONP：通过动态创建script，再请求一个带参网址实现跨域通信。document.domain +iframe 跨域：两个页面都通过js 强制设置document.domain 为基础主域，就实现了同域。location.hash + iframe 跨域：a 欲与b 跨域相互通信，通过中间页c 来实现。三个页面，不同域之间利用iframe 的location.hash 传值，相同域之间直接js 访问来通信。window.name + iframe 跨域：通过iframe 的src 属性由外域转向本地域，跨域数据即由iframe的window.name 从外域传递到本地域。</li>\n<li>postMessage 跨域：可以跨域操作的window 属性之一。</li>\n<li>CORS：服务端设置Access-Control-Allow-Origin 即可，前端无须设置，若要带cookie 请求，前后端都需要设置。</li>\n<li>代理跨域：起一个代理服务器，实现数据的转发</li>\n</ul>\n<h3 data-id=\"heading-4\">实现一个Ajax</h3>\n<p>AJAX 创建异步对象XMLHttpRequest操作XMLHttpRequest 对象</p>\n<ol>\n<li>设置请求参数（请求方式，请求页面的相对路径，是否异步）</li>\n<li>设置回调函数，一个处理服务器响应的函数，使用onreadystatechange ，类似函数指针</li>\n<li>获取异步对象的readyState 属性：该属性存有服务器响应的状态信息。每当readyState 改变时，onreadystatechange 函数就会被执行。</li>\n<li>判断响应报文的状态，若为200 说明服务器正常运行并返回响应数据。</li>\n<li>读取响应数据，可以通过responseText 属性来取回由服务器返回的数据。</li>\n</ol>', 0, 0, 0, 0, 1, 0, NULL, NULL, NULL);
INSERT INTO `cms_article` (`id`, `status`, `description`, `createTime`, `createBy`, `updateTime`, `updateBy`, `deleteStatus`, `deleteTime`, `deleteBy`, `title`, `summary`, `author`, `source`, `keywords`, `type`, `thumbId`, `fileId`, `contentUrl`, `mediaId`, `weight`, `content`, `browseCount`, `linkCount`, `collectCount`, `shareCount`, `isComment`, `commentCount`, `publishTime`, `publishBy`, `version`) VALUES ('90caa2d6-2194-49be-8108-01860297fcaa', 1, '', '2021-08-07 01:54:31.770892', NULL, '2021-09-24 16:19:49.000000', NULL, 0, NULL, NULL, '在腾讯工作是一种怎样的体验？', '先上工牌，今年夏天入职的鹅厂，坐标深圳', NULL, NULL, NULL, 0, '', 'c3d69deb-3a2b-4e16-8fe2-522d4f43f8d8', '', '', 0, '<div>\n<h2 data-id=\"heading-0\">生活</h2>\n<p>很幸运办公地点在滨海大厦，就是目前鹅厂最新的栋，可以竞选大厂最气派的办公地点了（没有之一）！！！</p>\n<p><img class=\"medium-zoom-image\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d50b19088a4d469391107a2c6147281d~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"\" /></p>\n<p><img class=\"medium-zoom-image\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f84573c856c4ed4882a499e10af1def~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"\" /></p>\n<p>室内也应有尽有，桌球、羽毛球、篮球、乒乓球、攀岩、瑜伽馆都有，还有室内跑道，健身房也超级大，而且全部免费对员工开放。</p>\n<p><img class=\"medium-zoom-image\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce6eda6d984a426db284d3e3f55671b6~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"image-20210805202120983\" /></p>\n<p>晚上健身房人也很多，虽然没有 work life balance，但是 work practice balance 还是很不错的！</p>\n<p><img class=\"medium-zoom-image\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77a35ca8c3c747d2a25b0a8f8fc1cb53~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"image-20210805202523230\" /></p>\n<p>室内的攀岩场，想问问这环境还有谁！！</p>\n<p>早餐都是免费的，不得不说滨海肠粉真的一绝，每次队伍都老长了。</p>\n<p><img class=\"medium-zoom-image\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/227dd57d8d514e55904d1a809f4e5fcd~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"image-20210805203448122\" /></p>\n<p>午餐是要自己花钱的，大概 20 左右，晚餐可以用夜宵券抵扣，基本都能随便吃，还能在附近的肯德基麦当劳用，夜宵券是只要八点之后下班就可以自动领一张（互联网公司的惯用督促加班技俩了）。</p>\n<p>随便吃真的想不胖都难！！</p>\n<p><img class=\"medium-zoom-image\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3daa81a600f84bfdbc66cbf2775466ed~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"image-20210722233410313\" /></p>\n<p>不得不说腾讯内部的各种内部工具是真的好用，电子工牌、腾讯访客这类小程序啥的老方便了，可以随时带朋友来参观大厦。</p>\n<h2 data-id=\"heading-1\">工作</h2>\n<p>再聊聊工作时长，每个部门的工作时间不一样，作息也不同，这边一般正常情况都是 995 左右，在项目上线阶段会加班。</p>\n<p>早上一般十点之前大家陆陆续续才到，中午一般十一点半左右去干饭，然后和同事散二十分钟步，聊聊互联网的大小事，然后午休到两点左右开始认真干货。</p>\n<p><img class=\"medium-zoom-image\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a41280f3b6a24dc5a71f95a47143e3c5~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"xx\" /></p>\n<blockquote>\n<p>在滨海看日落真的绝了</p>\n</blockquote>\n<p>晚上五点半左右干饭，干完散散步摸摸鱼，到快七点开始干活。</p>\n<p>满打满算每天真正工作时间可能也就在八小时左右，当然这是在比较闲的情况下，加班当然是有的，遇到项目上线到凌晨也是有的。</p>\n<h2 data-id=\"heading-2\">福利</h2>\n<p>无大小周、每月半价 Q 币、每年免费洁一次牙、部门团建、员工子女专属 QQ 号加 18 年 QQ 会员、免息贷款、节假日礼包、开工利是，马爸爸对待员工还是好不吝啬的。</p>\n<p><a title=\"https://imgtu.com/i/WDHE9J\" href=\"https://link.juejin.cn?target=https%3A%2F%2Fimgtu.com%2Fi%2FWDHE9J\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d079b01f5a064c28ae5831af5a69d6b0~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"WDHE9J.jpg\" /></a></p>\n<blockquote>\n<p>公仔厂的外号也不是吹的！</p>\n</blockquote>\n<p>去年的阳光普照奖（约等于6w+），各种加一起总包在大厂中也能达到第一梯队了，不过年终如何还是得看部门，据说在人上人 wxg 二十几薪的也不少。</p>\n<h2 data-id=\"heading-3\">氛围</h2>\n<p>同事大多 985 起步，其中不乏各种海归，研究生也遍地都是，大佬很多，卧虎藏龙，可能走在路上一个其貌不扬的人，就是某个领域的大牛。</p>\n<p>当然了，双非也是有的，笔者就是，不过比例还是比较少的，原因懂的都懂吧。。。</p>\n<p>不过上下级之间管理会相对扁平化，有可能坐你对面工位的就是某某总监，旁边就是某某 Leader。公司内 35 岁以上的前辈也很多，听一些前辈讲中年危机并没有网上所散播的那么严重。</p>\n<p>技术层面将其实看部门，有些部门会有很多历史遗留项目，\"屎山\"也是有的，\"铲屎\"痛不欲生的感觉几乎没有人想去感受。</p>\n<p>不过，部门与部门的差距往往有时候能大过宇宙，在鹅厂非常牛通的部门也有很多，比如天美、微信。。</p>\n<p>技术氛围还是可以的，不同部门也有很多内部的框架，有一些没有开源，只是内部使用，还有一些比较有名的开源项目比如 RPC 框架 tars。</p>\n<p>公司内部的培训很多，明天可能会收到好几封讲座的邮件，很多不仅能听到大牛分享经验，有时候还能顺手领个T恤公仔啥的。</p>\n<p>对了。。公仔还能在楼下爱马哥(image&mdash;鹅厂自营店) 店里买，又一个工资回收计划。。</p>\n<p><img class=\"medium-zoom-image\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df0d0df6ab2e46589917784b6454d7e4~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"31772E5D064627E0CA45FB7BFCE40E89\" /></p>\n<h2 data-id=\"heading-4\">总结</h2>\n<p>虽然腾讯在大多数地方做的几乎都非常好，但还是有一些不那么好的地方，比如工作压力，这个地方没有人会 push 你，上级只会要求你做的要比期望的更好，如果你完成了你应该做的任务，你只是一名<code>合格</code>的员工，也就是中等绩效，你只能去不断 push 自己，这也是我们所说的<code>自驱力</code>吧。</p>\n<p>虽然压力大，但起码，在大厂，收获与付出是等价的。</p>\n<p>文章的最后，给大家推荐一个 github ，<a title=\"https://github.com/crisxuan/bestJavaer\" href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcrisxuan%2FbestJavaer\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">github.com/crisxuan/be&hellip;</a> 这个 github 是我呕心沥血所有文章的汇总，非常硬核， 欢迎 star 。</p>\n</div>', 0, 0, 0, 0, 1, 0, NULL, NULL, NULL);
INSERT INTO `cms_article` (`id`, `status`, `description`, `createTime`, `createBy`, `updateTime`, `updateBy`, `deleteStatus`, `deleteTime`, `deleteBy`, `title`, `summary`, `author`, `source`, `keywords`, `type`, `thumbId`, `fileId`, `contentUrl`, `mediaId`, `weight`, `content`, `browseCount`, `linkCount`, `collectCount`, `shareCount`, `isComment`, `commentCount`, `publishTime`, `publishBy`, `version`) VALUES ('b00ad000-e454-4773-9216-27ca1d0ce0b3', 1, '1111111111111', '2021-09-22 14:12:10.066410', '62310947-7b54-45c8-a5da-19837f2541a4', '2021-09-30 09:25:02.000000', NULL, 0, NULL, NULL, '123456', '监听当前实例上的自定义事件。事件可以由 vm.$emit 触发。回调函数会接收所有传入事件触发函数的额外参数。监听当前实例上的自定义事件。监听当前实例上的自定义事件。事件可以由 vm.$emit 触发。回调函数会接收所有传入事件触发函数的额外参数。监听当前实例上的自定义事件。', '111111222', '222222222', NULL, 3, '0b159c77-607d-43d1-a1f2-3309dd016a9f', 'e020a234-6fcc-4212-9e81-cec233caa378', '', '84c8d5eb-df44-44cc-9ce2-96fc1370c420,621ab2ae-e382-41d7-8f30-4fb5e0c16ddf', 0, '<p>weewrewfwefdew</p>', 0, 0, 0, 0, 1, 0, '2021-09-30 01:25:02', '62310947-7b54-45c8-a5da-19837f2541a4', NULL);
INSERT INTO `cms_article` (`id`, `status`, `description`, `createTime`, `createBy`, `updateTime`, `updateBy`, `deleteStatus`, `deleteTime`, `deleteBy`, `title`, `summary`, `author`, `source`, `keywords`, `type`, `thumbId`, `fileId`, `contentUrl`, `mediaId`, `weight`, `content`, `browseCount`, `linkCount`, `collectCount`, `shareCount`, `isComment`, `commentCount`, `publishTime`, `publishBy`, `version`) VALUES ('bdf078c5-bb0f-42b3-8317-1a06792fa1ee', 1, '', '2021-08-07 01:51:36.699893', NULL, '2021-09-24 16:19:49.000000', NULL, 0, NULL, NULL, '浏览器工作原理与实践', '透过浏览器看懂前端本质', NULL, NULL, NULL, 1, '', NULL, 'https://time.geekbang.org/column/intro/216', '', 0, '', 0, 0, 0, 0, 1, 0, NULL, NULL, NULL);
INSERT INTO `cms_article` (`id`, `status`, `description`, `createTime`, `createBy`, `updateTime`, `updateBy`, `deleteStatus`, `deleteTime`, `deleteBy`, `title`, `summary`, `author`, `source`, `keywords`, `type`, `thumbId`, `fileId`, `contentUrl`, `mediaId`, `weight`, `content`, `browseCount`, `linkCount`, `collectCount`, `shareCount`, `isComment`, `commentCount`, `publishTime`, `publishBy`, `version`) VALUES ('c9516241-7bc2-4b1b-a444-7419021903b6', 0, '', '2021-08-17 00:03:50.084883', NULL, '2021-09-24 16:19:49.000000', NULL, 0, NULL, NULL, '设计方案，写了才知道有多香', '设计方案，写了才知道有多香', NULL, NULL, NULL, 0, '', NULL, '', '', 0, '<div>\n<h1 data-id=\"heading-0\">设计方案，拿来吧你</h1>\n<p>大家好，我是<strong>零一</strong>，今天要跟大家聊聊开发流程中不起眼的环节&mdash;&mdash;<strong>设计方案</strong>。你们可能没听过，也可能只是简单得走过过场，别划走，这非常重要！</p>\n<p>在字节，我接触到了更完善、更规范、更高效的开发流程：<strong>产品需求设计</strong> =&gt; <strong>需求粗评</strong> =&gt; <strong>做设计方案</strong> =&gt; <strong>粗估时</strong> =&gt; <strong>需求细评</strong> =&gt; <strong>排期</strong> =&gt; <strong>开发</strong> =&gt; <strong>提测、修bug</strong> =&gt; <strong>code review</strong> =&gt; <strong>上线</strong></p>\n<p>其实在我未工作之前，大部分的流程我都听说过或者在实习时经历过，比较少接触的可能就是<strong>设计方案</strong>和<strong>code review</strong>了，这两者分别是干什么的？</p>\n<ul>\n<li><strong>设计方案</strong>：在拿到需求后，写一个文档，来描述自己对于该需求的实现思路、模块划分等相关考虑的点，可供今后自己或他人查阅</li>\n<li><strong>Code review</strong>：代码提交合并前给mentor或leader检查一下你的代码，让别人作为旁观者来看你的代码，集思广益，完善代码，发现未考虑到的边界问题</li>\n</ul>\n<p>说实话哈，啥设计方案啊，我第一次在一家小公司实习的时候，突然就被产品叫过去，花5分钟给我阐述了一下下个版本他想要上的功能，紧接着立马就问我：<strong>你看看大概需要多久？我的预估是5天后就上线，ok吗？</strong></p>\n<p>我： <strong>？？？？？？？？？</strong> （内心os：我刚知道这个需求，我哪能那么快知道我得花多久做出来啊！你说5天就5天吧，反正我说6天也没用）</p>\n</div>', 0, 0, 0, 0, 1, 0, NULL, NULL, NULL);
INSERT INTO `cms_article` (`id`, `status`, `description`, `createTime`, `createBy`, `updateTime`, `updateBy`, `deleteStatus`, `deleteTime`, `deleteBy`, `title`, `summary`, `author`, `source`, `keywords`, `type`, `thumbId`, `fileId`, `contentUrl`, `mediaId`, `weight`, `content`, `browseCount`, `linkCount`, `collectCount`, `shareCount`, `isComment`, `commentCount`, `publishTime`, `publishBy`, `version`) VALUES ('d064ec1b-5e43-4b6d-aa6e-444513c130b4', 1, '', '2021-08-07 01:52:42.746599', NULL, '2021-09-24 16:19:49.000000', NULL, 0, NULL, NULL, '最小化K8s环境部署之Minikube', '这是我参与8月更文挑战的第1天，活动详情查看:8月更文挑战', NULL, NULL, NULL, 0, '', NULL, '', '', 0, '<div>\n<h1 data-id=\"heading-0\">最小化K8s环境部署之Minikube</h1>\n<h1 data-id=\"heading-1\">一 背景</h1>\n<p>最近需要给开发相关同时培训K8s，集群方式部署负责且占用资源多，简单快捷高效的单机版K8s环境，可谓开发人员不错的选择，minikube就是为解决这个问题而衍生出来的工具，它基于go语言开发， 是一个易于在本地运行 Kubernetes 的工具，可在你的笔记本电脑上的虚拟机内轻松创建单机版 Kubernetes 集群。便于尝试 Kubernetes 或使用 Kubernetes 日常开发。可以在单机环境下快速搭建可用的k8s集群，非常适合测试和本地开发。如果没有服务器或在本地笔记本安装，则可以在线使用<a title=\"https://labs.play-with-k8s.com/%E6%9D%A5%E4%BD%93%E9%AA%8CK8s%E3%80%82\" href=\"https://link.juejin.cn?target=https%3A%2F%2Flabs.play-with-k8s.com%2F%25E6%259D%25A5%25E4%25BD%2593%25E9%25AA%258CK8s%25E3%2580%2582\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">labs.play-with-k8s.com/来体验K8s。</a></p>\n<h1 data-id=\"heading-2\">二 Minikube简介</h1>\n<h2 data-id=\"heading-3\">2.1 主要组件</h2>\n<h3 data-id=\"heading-4\"><strong>localkube</strong></h3>\n<p>为了运行和管理 Kubernetes 的组件，Minikube 中使用了 Spread\'s 的 localkube，localkube 是一个独立的 Go 语言的二进制包，包含了所有 Kubernetes 的主要组件，并且以不同的 goroutine 来运行。</p>\n<h3 data-id=\"heading-5\"><strong>libmachine</strong></h3>\n<p>为了支持 MacOS 和 Windows，Minikube 在内部使用 libmachine 创建或销毁虚拟机，可以将它理解为一个虚拟机的驱动程序。至于在 Linux 上，由于集群可以直接本地运行，所以避免设置虚拟机。</p>\n<h2 data-id=\"heading-6\">2.2 启动流程</h2>\n<ul>\n<li>通过 libmachine 启动虚拟机，生成 Docker 相关证书及配置文件，启动 Docker;</li>\n<li>生成 Kubernetes 相关配置文件和 addons，以及相关证书，拷贝至虚拟机;</li>\n<li>基于之前的配置文件，生成启动脚本，启动 Kubernetes 集群，并可以通过 Client 进行访问。</li>\n</ul>\n<h3 data-id=\"heading-7\">MacOS/Windows</h3>\n<ul>\n<li>minikube -&gt; libmachine -&gt; virtualbox/hyper V -&gt; linux VM -&gt; localkube</li>\n</ul>\n<h3 data-id=\"heading-8\">Linux</h3>\n<ul>\n<li>minikube -&gt; docker -&gt; localkube</li>\n</ul>\n</div>', 0, 0, 0, 0, 1, 0, NULL, NULL, NULL);
